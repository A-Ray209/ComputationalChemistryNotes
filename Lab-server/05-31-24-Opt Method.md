### 调控计算方法

#### 1. 溶剂化效应


产生输入   计算  提取结果

快有3种（LR+cLR+SS)
慢有2种（基态溶剂壳+激发态溶剂壳）

产生输入
```
0 opt s0 + td(50-50)                                            # 无溶剂化效应
qcinp.py --steps "td(50-50,nstates=5) PBE1PBE def2svp g09default geom=allcheck guess=read" -A _n00 DMB.log

1 opt s0 + td(50-50) scrf                                       # 溶剂化基态 + 溶剂化激发态电子响应（LR）
qcinp.py --steps "td(50-50,nstates=5) PBE1PBE def2svp g09default scrf(solvent=diphenylether) geom=allcheck guess=read" -A _n01 DMB.log

2 opt s0 + td(50-50) density scrf                               # 溶剂化第一激发态/溶剂化原子,线性响应
qcinp.py --steps "td(50-50,nstates=5) PBE1PBE def2svp g09default scrf(solvent=diphenylether) density geom=allcheck guess=read" -A _n02 DMB.log

3 opt s0 + td(50-50) density scrf(correctedLR)                  # 溶剂化第一激激发态/溶剂化原子,矫正的线性响应（CLR）
qcinp.py --steps "td(50-50,nstates=5) PBE1PBE def2svp g09default scrf(solvent=diphenylether,correctedLR)  geom=allcheck guess=read" -A _n03 DMB.log

4 opt s0 + td(50-50) density scrf(ExternalIteration)            # 溶剂化第一激激发态/溶剂化原子,态特定电子响应（SS），默认指定态为1（ROOT=1）
qcinp.py --steps "td(50-50,nstates=5) PBE1PBE def2svp g09default scrf(solvent=diphenylether,externaliteration) density geom=allcheck guess=read" -A _n04 DMB.log

5 opt s0 + td(50-50) scrf(ExternalIteration)                    #溶剂化第一激激发态/溶剂化电子响应（SS）
qcinp.py --steps "td(50-50,nstates=5) PBE1PBE def2svp g09default scrf(solvent=diphenylether,externaliteration) geom=allcheck guess=read" -A _n05 DMB.log

6 opt s0 + td density scrf    +    td(triplets)  scrf										   # 溶剂化基态 + 溶剂化第一/三激发态电子响应（LR）
7 opt s0 + td density scrf    +    td(triplets) density scrf                                   # 溶剂化第一/三激发态 溶剂化原子,线性响应
8 opt s0 + td density scrf(correctedLR)    +    td(triplets) density scrf(correctedLR)         # 溶剂化第一/三激发态 溶剂化原子,矫正的线性响应（CLR）
9 opt s0 + td density scrf(correctedLR)    +    td(triplets) density scrf(ExternalIteration)   # 溶剂化第一/三激发态 # 溶剂化第一激激发态/溶剂化原子,态特定电子响应（SS），默认指定态为1（ROOT=1）
```

计算： g16s *.gjf ，结果：
```
tmwfn.py -e st1 DMB_n0*.log  # 查看计算能量
tmwfn.py -p d DMB_n*.log     # 查看分子偶极
```

态交叉的影响因素：在更换溶剂，泛函，振动会使 CT 态和 LE 发生交叉，影响计算结果


#### 2. 不同泛函影响

##### 2.1 不同泛函具体影响

不同 DFT 泛函的 HF （hatree-fock）成份

泛函 HF% PBE0 25%  B3LYP 20% M062x 52% cam-b3lyp 20%--100% wb97xd lcwhpbe

 HF （hatree-fock）成份越高越容易 LE

##### 2.2 分别使用不同泛函计算（手动）

将基态优化后的文件 DMB.log 放入 func 文件夹

输入命令，分别产生不同泛函的计算文件
```
qcinp.py -r "PBE1PBE em" -a "b3lyp|cam-b3lyp|wb97xd|m062x|lcwhpbe" DMB.log   # “|” 表示分别加入内容
```
计算： g16s *.gjf ，结果：
```
tmwfn.py -e st1 DMB_n0*.log  # 查看计算能量
tmwfn.py -p d DMB_n*.log     # 查看分子偶极
```
##### 2.3 调控密度泛函（自动）

调控密度泛函，对计算方法进行优化，Gaussian 程序会不断调节计算方法，使得某一种计算方法在不同计算方式下得到相同的结果，此时认为该计算方法较为合适。

调控过程如下

将 gjf 表头修改为下列内容
```
git clone https://gitee.com/coordmagic/xwtune           # 计算调控泛函需要的脚本，添加环境变量

修改 g16s 中的代码，将 g09 改为 g16

qcinp.py -k "lc-whpbe/def2svp g09default" DMB.log       # 重写表头命令

(base) [jzq@node01 wtune]$ head DMB.gjf
%chk=DMB.chk
%nproc=40
%mem=100GB
#p lc-whpbe/def2svp g09default

DMB

0 1
N             1.202154    1.242241    1.040853
N            -3.200761   -1.840113   -0.583320
...
```
然后输入下面命令提交调控任务
```
g16s -t " " DMB.gjf
```
计算结束后，会有如下计算文件，查看其表头，内容为
```
(base) [jzq@node01 wtune]$ head DMB_lc-whpbe_def2svp_J2_tuned.gjf
%chk=DMB_lc-whpbe_def2svp_w01661_n.chk
%nprocshared=40
%mem=100GB
#p lc-whpbe/def2svp g09default scf(xqc,conver=6) Int(ultrafine) guess=read IOP(3/107=0166100000) IOP(3/108=0166100000)

Tuning input file generated by xtune with parameters: w01661

0 1
N             1.202154    1.242241    1.040853
N            -3.200761   -1.840113   -0.583320
...
```
后续计算均使用这些关键字进行计算

#### 3. 加振动































































